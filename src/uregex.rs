#![allow(unused_imports)]
/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
use libc;
use libc::*;
use utypes::*;
use ustring::*;
use utf8::*;
use utf16::*;
use uchar::*;
use uscript::*;
use uset::*;
use ucnv::*;
use uloc::*;
use ures::*;
use unorm2::*;
use ucal::*;
use udat::*;
use unum::*;
use utrans::*;
use ubidi::*;
use ushape::*;
use ucol::*;
use usearch::*;
use ubrk::*;
use usprep::*;
use uidna::*;
use uspoof::*;
use utmscale::*;
use umachine::*;
use parseerr::*;
use utext::*;
use uversion::*;
use uiter::*;
use uenum::*;
use urep::*;
use udisplaycontext::*;
use uformattable::*;
use umisc::*;
use ufieldpositer::*;
use ucnv_err::*;
use ucasemap::*;

pub enum URegularExpression { }
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
#[derive(PartialEq,Eq,PartialOrd,Ord,Hash)]
pub enum URegexpFlag {
    UREGEX_CANON_EQ = 128,
    UREGEX_CASE_INSENSITIVE = 2,
    UREGEX_COMMENTS = 4,
    UREGEX_DOTALL = 32,
    UREGEX_LITERAL = 16,
    UREGEX_MULTILINE = 8,
    UREGEX_UNIX_LINES = 1,
    UREGEX_UWORD = 256,
    UREGEX_ERROR_ON_UNKNOWN_ESCAPES = 512,
}
pub type URegexMatchCallback =
    ::std::option::Option<unsafe extern "C" fn(context:
                                                   *const ::std::os::raw::c_void,
                                               steps: int32_t) -> UBool>;
pub type URegexFindProgressCallback =
    ::std::option::Option<unsafe extern "C" fn(context:
                                                   *const ::std::os::raw::c_void,
                                               matchIndex: int64_t) -> UBool>;
#[link(name = "icuuc", kind = "static")]
#[link(name = "icudata", kind = "static")] 
#[link(name = "icui18n", kind = "static")] 
#[link(name = "stdc++", kind = "dylib")]
extern "C" {
    pub fn uregex_open(pattern: *const UChar, patternLength: int32_t,
                       flags: uint32_t, pe: *mut UParseError,
                       status: *mut UErrorCode) -> *mut URegularExpression;
    pub fn uregex_openUText(pattern: *mut UText, flags: uint32_t,
                            pe: *mut UParseError, status: *mut UErrorCode)
     -> *mut URegularExpression;
    pub fn uregex_openC(pattern: *const ::std::os::raw::c_char,
                        flags: uint32_t, pe: *mut UParseError,
                        status: *mut UErrorCode) -> *mut URegularExpression;
    pub fn uregex_close(regexp: *mut URegularExpression);
    pub fn uregex_clone(regexp: *const URegularExpression,
                        status: *mut UErrorCode) -> *mut URegularExpression;
    pub fn uregex_pattern(regexp: *const URegularExpression,
                          patLength: *mut int32_t, status: *mut UErrorCode)
     -> *const UChar;
    pub fn uregex_patternUText(regexp: *const URegularExpression,
                               status: *mut UErrorCode) -> *mut UText;
    pub fn uregex_flags(regexp: *const URegularExpression,
                        status: *mut UErrorCode) -> int32_t;
    pub fn uregex_setText(regexp: *mut URegularExpression, text: *const UChar,
                          textLength: int32_t, status: *mut UErrorCode);
    pub fn uregex_setUText(regexp: *mut URegularExpression, text: *mut UText,
                           status: *mut UErrorCode);
    pub fn uregex_getText(regexp: *mut URegularExpression,
                          textLength: *mut int32_t, status: *mut UErrorCode)
     -> *const UChar;
    pub fn uregex_getUText(regexp: *mut URegularExpression, dest: *mut UText,
                           status: *mut UErrorCode) -> *mut UText;
    pub fn uregex_refreshUText(regexp: *mut URegularExpression,
                               text: *mut UText, status: *mut UErrorCode);
    pub fn uregex_matches(regexp: *mut URegularExpression,
                          startIndex: int32_t, status: *mut UErrorCode)
     -> UBool;
    pub fn uregex_matches64(regexp: *mut URegularExpression,
                            startIndex: int64_t, status: *mut UErrorCode)
     -> UBool;
    pub fn uregex_lookingAt(regexp: *mut URegularExpression,
                            startIndex: int32_t, status: *mut UErrorCode)
     -> UBool;
    pub fn uregex_lookingAt64(regexp: *mut URegularExpression,
                              startIndex: int64_t, status: *mut UErrorCode)
     -> UBool;
    pub fn uregex_find(regexp: *mut URegularExpression, startIndex: int32_t,
                       status: *mut UErrorCode) -> UBool;
    pub fn uregex_find64(regexp: *mut URegularExpression, startIndex: int64_t,
                         status: *mut UErrorCode) -> UBool;
    pub fn uregex_findNext(regexp: *mut URegularExpression,
                           status: *mut UErrorCode) -> UBool;
    pub fn uregex_groupCount(regexp: *mut URegularExpression,
                             status: *mut UErrorCode) -> int32_t;
    pub fn uregex_groupNumberFromName(regexp: *mut URegularExpression,
                                      groupName: *const UChar,
                                      nameLength: int32_t,
                                      status: *mut UErrorCode) -> int32_t;
    pub fn uregex_groupNumberFromCName(regexp: *mut URegularExpression,
                                       groupName:
                                           *const ::std::os::raw::c_char,
                                       nameLength: int32_t,
                                       status: *mut UErrorCode) -> int32_t;
    pub fn uregex_group(regexp: *mut URegularExpression, groupNum: int32_t,
                        dest: *mut UChar, destCapacity: int32_t,
                        status: *mut UErrorCode) -> int32_t;
    pub fn uregex_groupUText(regexp: *mut URegularExpression,
                             groupNum: int32_t, dest: *mut UText,
                             groupLength: *mut int64_t,
                             status: *mut UErrorCode) -> *mut UText;
    pub fn uregex_start(regexp: *mut URegularExpression, groupNum: int32_t,
                        status: *mut UErrorCode) -> int32_t;
    pub fn uregex_start64(regexp: *mut URegularExpression, groupNum: int32_t,
                          status: *mut UErrorCode) -> int64_t;
    pub fn uregex_end(regexp: *mut URegularExpression, groupNum: int32_t,
                      status: *mut UErrorCode) -> int32_t;
    pub fn uregex_end64(regexp: *mut URegularExpression, groupNum: int32_t,
                        status: *mut UErrorCode) -> int64_t;
    pub fn uregex_reset(regexp: *mut URegularExpression, index: int32_t,
                        status: *mut UErrorCode);
    pub fn uregex_reset64(regexp: *mut URegularExpression, index: int64_t,
                          status: *mut UErrorCode);
    pub fn uregex_setRegion(regexp: *mut URegularExpression,
                            regionStart: int32_t, regionLimit: int32_t,
                            status: *mut UErrorCode);
    pub fn uregex_setRegion64(regexp: *mut URegularExpression,
                              regionStart: int64_t, regionLimit: int64_t,
                              status: *mut UErrorCode);
    pub fn uregex_setRegionAndStart(regexp: *mut URegularExpression,
                                    regionStart: int64_t,
                                    regionLimit: int64_t, startIndex: int64_t,
                                    status: *mut UErrorCode);
    pub fn uregex_regionStart(regexp: *const URegularExpression,
                              status: *mut UErrorCode) -> int32_t;
    pub fn uregex_regionStart64(regexp: *const URegularExpression,
                                status: *mut UErrorCode) -> int64_t;
    pub fn uregex_regionEnd(regexp: *const URegularExpression,
                            status: *mut UErrorCode) -> int32_t;
    pub fn uregex_regionEnd64(regexp: *const URegularExpression,
                              status: *mut UErrorCode) -> int64_t;
    pub fn uregex_hasTransparentBounds(regexp: *const URegularExpression,
                                       status: *mut UErrorCode) -> UBool;
    pub fn uregex_useTransparentBounds(regexp: *mut URegularExpression,
                                       b: UBool, status: *mut UErrorCode);
    pub fn uregex_hasAnchoringBounds(regexp: *const URegularExpression,
                                     status: *mut UErrorCode) -> UBool;
    pub fn uregex_useAnchoringBounds(regexp: *mut URegularExpression,
                                     b: UBool, status: *mut UErrorCode);
    pub fn uregex_hitEnd(regexp: *const URegularExpression,
                         status: *mut UErrorCode) -> UBool;
    pub fn uregex_requireEnd(regexp: *const URegularExpression,
                             status: *mut UErrorCode) -> UBool;
    pub fn uregex_replaceAll(regexp: *mut URegularExpression,
                             replacementText: *const UChar,
                             replacementLength: int32_t, destBuf: *mut UChar,
                             destCapacity: int32_t, status: *mut UErrorCode)
     -> int32_t;
    pub fn uregex_replaceAllUText(regexp: *mut URegularExpression,
                                  replacement: *mut UText, dest: *mut UText,
                                  status: *mut UErrorCode) -> *mut UText;
    pub fn uregex_replaceFirst(regexp: *mut URegularExpression,
                               replacementText: *const UChar,
                               replacementLength: int32_t,
                               destBuf: *mut UChar, destCapacity: int32_t,
                               status: *mut UErrorCode) -> int32_t;
    pub fn uregex_replaceFirstUText(regexp: *mut URegularExpression,
                                    replacement: *mut UText, dest: *mut UText,
                                    status: *mut UErrorCode) -> *mut UText;
    pub fn uregex_appendReplacement(regexp: *mut URegularExpression,
                                    replacementText: *const UChar,
                                    replacementLength: int32_t,
                                    destBuf: *mut *mut UChar,
                                    destCapacity: *mut int32_t,
                                    status: *mut UErrorCode) -> int32_t;
    pub fn uregex_appendReplacementUText(regexp: *mut URegularExpression,
                                         replacementText: *mut UText,
                                         dest: *mut UText,
                                         status: *mut UErrorCode);
    pub fn uregex_appendTail(regexp: *mut URegularExpression,
                             destBuf: *mut *mut UChar,
                             destCapacity: *mut int32_t,
                             status: *mut UErrorCode) -> int32_t;
    pub fn uregex_appendTailUText(regexp: *mut URegularExpression,
                                  dest: *mut UText, status: *mut UErrorCode)
     -> *mut UText;
    pub fn uregex_split(regexp: *mut URegularExpression, destBuf: *mut UChar,
                        destCapacity: int32_t, requiredCapacity: *mut int32_t,
                        destFields: *mut *mut UChar,
                        destFieldsCapacity: int32_t, status: *mut UErrorCode)
     -> int32_t;
    pub fn uregex_splitUText(regexp: *mut URegularExpression,
                             destFields: *mut *mut UText,
                             destFieldsCapacity: int32_t,
                             status: *mut UErrorCode) -> int32_t;
    pub fn uregex_setTimeLimit(regexp: *mut URegularExpression,
                               limit: int32_t, status: *mut UErrorCode);
    pub fn uregex_getTimeLimit(regexp: *const URegularExpression,
                               status: *mut UErrorCode) -> int32_t;
    pub fn uregex_setStackLimit(regexp: *mut URegularExpression,
                                limit: int32_t, status: *mut UErrorCode);
    pub fn uregex_getStackLimit(regexp: *const URegularExpression,
                                status: *mut UErrorCode) -> int32_t;
    pub fn uregex_setMatchCallback(regexp: *mut URegularExpression,
                                   callback: URegexMatchCallback,
                                   context: *const ::std::os::raw::c_void,
                                   status: *mut UErrorCode);
    pub fn uregex_getMatchCallback(regexp: *const URegularExpression,
                                   callback: *mut URegexMatchCallback,
                                   context:
                                       *mut *const ::std::os::raw::c_void,
                                   status: *mut UErrorCode);
    pub fn uregex_setFindProgressCallback(regexp: *mut URegularExpression,
                                          callback:
                                              URegexFindProgressCallback,
                                          context:
                                              *const ::std::os::raw::c_void,
                                          status: *mut UErrorCode);
    pub fn uregex_getFindProgressCallback(regexp: *const URegularExpression,
                                          callback:
                                              *mut URegexFindProgressCallback,
                                          context:
                                              *mut *const ::std::os::raw::c_void,
                                          status: *mut UErrorCode);
}
