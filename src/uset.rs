#![allow(unused_imports)]
/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
use libc;
use libc::*;
use utypes::*;
use ustring::*;
use utf8::*;
use utf16::*;
use uchar::*;
use uscript::*;
use ucnv::*;
use uloc::*;
use ures::*;
use unorm2::*;
use ucal::*;
use udat::*;
use unum::*;
use utrans::*;
use ubidi::*;
use ushape::*;
use ucol::*;
use usearch::*;
use ubrk::*;
use uregex::*;
use usprep::*;
use uidna::*;
use uspoof::*;
use utmscale::*;
use umachine::*;
use parseerr::*;
use utext::*;
use uversion::*;
use uiter::*;
use uenum::*;
use urep::*;
use udisplaycontext::*;
use uformattable::*;
use umisc::*;
use ufieldpositer::*;
use ucnv_err::*;
use ucasemap::*;

pub enum USet { }
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
#[derive(PartialEq,Eq,PartialOrd,Ord,Hash)]
pub enum Enum_uset1 {
    USET_IGNORE_SPACE = 1,
    USET_CASE_INSENSITIVE = 2,
    USET_ADD_CASE_MAPPINGS = 4,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
#[derive(PartialEq,Eq,PartialOrd,Ord,Hash)]
pub enum USetSpanCondition {
    USET_SPAN_NOT_CONTAINED = 0,
    USET_SPAN_CONTAINED = 1,
    USET_SPAN_SIMPLE = 2,
    USET_SPAN_CONDITION_COUNT = 3,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_uset2 { USET_SERIALIZED_STATIC_ARRAY_CAPACITY = 8, }
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct USerializedSet {
    pub array: *const uint16_t,
    pub bmpLength: int32_t,
    pub length: int32_t,
    pub staticArray: [uint16_t; 8usize],
}
impl ::std::default::Default for USerializedSet {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[link(name = "icuuc", kind = "static")]
#[link(name = "icudata", kind = "static")] 
#[link(name = "icui18n", kind = "static")] 
#[link(name = "stdc++", kind = "dylib")]
extern "C" {
    pub fn uset_openEmpty() -> *mut USet;
    pub fn uset_open(start: UChar32, end: UChar32) -> *mut USet;
    pub fn uset_openPattern(pattern: *const UChar, patternLength: int32_t,
                            ec: *mut UErrorCode) -> *mut USet;
    pub fn uset_openPatternOptions(pattern: *const UChar,
                                   patternLength: int32_t, options: uint32_t,
                                   ec: *mut UErrorCode) -> *mut USet;
    pub fn uset_close(set: *mut USet);
    pub fn uset_clone(set: *const USet) -> *mut USet;
    pub fn uset_isFrozen(set: *const USet) -> UBool;
    pub fn uset_freeze(set: *mut USet);
    pub fn uset_cloneAsThawed(set: *const USet) -> *mut USet;
    pub fn uset_set(set: *mut USet, start: UChar32, end: UChar32);
    pub fn uset_applyPattern(set: *mut USet, pattern: *const UChar,
                             patternLength: int32_t, options: uint32_t,
                             status: *mut UErrorCode) -> int32_t;
    pub fn uset_applyIntPropertyValue(set: *mut USet, prop: UProperty,
                                      value: int32_t, ec: *mut UErrorCode);
    pub fn uset_applyPropertyAlias(set: *mut USet, prop: *const UChar,
                                   propLength: int32_t, value: *const UChar,
                                   valueLength: int32_t, ec: *mut UErrorCode);
    pub fn uset_resemblesPattern(pattern: *const UChar,
                                 patternLength: int32_t, pos: int32_t)
     -> UBool;
    pub fn uset_toPattern(set: *const USet, result: *mut UChar,
                          resultCapacity: int32_t, escapeUnprintable: UBool,
                          ec: *mut UErrorCode) -> int32_t;
    pub fn uset_add(set: *mut USet, c: UChar32);
    pub fn uset_addAll(set: *mut USet, additionalSet: *const USet);
    pub fn uset_addRange(set: *mut USet, start: UChar32, end: UChar32);
    pub fn uset_addString(set: *mut USet, str: *const UChar, strLen: int32_t);
    pub fn uset_addAllCodePoints(set: *mut USet, str: *const UChar,
                                 strLen: int32_t);
    pub fn uset_remove(set: *mut USet, c: UChar32);
    pub fn uset_removeRange(set: *mut USet, start: UChar32, end: UChar32);
    pub fn uset_removeString(set: *mut USet, str: *const UChar,
                             strLen: int32_t);
    pub fn uset_removeAll(set: *mut USet, removeSet: *const USet);
    pub fn uset_retain(set: *mut USet, start: UChar32, end: UChar32);
    pub fn uset_retainAll(set: *mut USet, retain: *const USet);
    pub fn uset_compact(set: *mut USet);
    pub fn uset_complement(set: *mut USet);
    pub fn uset_complementAll(set: *mut USet, complement: *const USet);
    pub fn uset_clear(set: *mut USet);
    pub fn uset_closeOver(set: *mut USet, attributes: int32_t);
    pub fn uset_removeAllStrings(set: *mut USet);
    pub fn uset_isEmpty(set: *const USet) -> UBool;
    pub fn uset_contains(set: *const USet, c: UChar32) -> UBool;
    pub fn uset_containsRange(set: *const USet, start: UChar32, end: UChar32)
     -> UBool;
    pub fn uset_containsString(set: *const USet, str: *const UChar,
                               strLen: int32_t) -> UBool;
    pub fn uset_indexOf(set: *const USet, c: UChar32) -> int32_t;
    pub fn uset_charAt(set: *const USet, charIndex: int32_t) -> UChar32;
    pub fn uset_size(set: *const USet) -> int32_t;
    pub fn uset_getItemCount(set: *const USet) -> int32_t;
    pub fn uset_getItem(set: *const USet, itemIndex: int32_t,
                        start: *mut UChar32, end: *mut UChar32,
                        str: *mut UChar, strCapacity: int32_t,
                        ec: *mut UErrorCode) -> int32_t;
    pub fn uset_containsAll(set1: *const USet, set2: *const USet) -> UBool;
    pub fn uset_containsAllCodePoints(set: *const USet, str: *const UChar,
                                      strLen: int32_t) -> UBool;
    pub fn uset_containsNone(set1: *const USet, set2: *const USet) -> UBool;
    pub fn uset_containsSome(set1: *const USet, set2: *const USet) -> UBool;
    pub fn uset_span(set: *const USet, s: *const UChar, length: int32_t,
                     spanCondition: USetSpanCondition) -> int32_t;
    pub fn uset_spanBack(set: *const USet, s: *const UChar, length: int32_t,
                         spanCondition: USetSpanCondition) -> int32_t;
    pub fn uset_spanUTF8(set: *const USet, s: *const ::std::os::raw::c_char,
                         length: int32_t, spanCondition: USetSpanCondition)
     -> int32_t;
    pub fn uset_spanBackUTF8(set: *const USet,
                             s: *const ::std::os::raw::c_char,
                             length: int32_t,
                             spanCondition: USetSpanCondition) -> int32_t;
    pub fn uset_equals(set1: *const USet, set2: *const USet) -> UBool;
    pub fn uset_serialize(set: *const USet, dest: *mut uint16_t,
                          destCapacity: int32_t, pErrorCode: *mut UErrorCode)
     -> int32_t;
    pub fn uset_getSerializedSet(fillSet: *mut USerializedSet,
                                 src: *const uint16_t, srcLength: int32_t)
     -> UBool;
    pub fn uset_setSerializedToOne(fillSet: *mut USerializedSet, c: UChar32);
    pub fn uset_serializedContains(set: *const USerializedSet, c: UChar32)
     -> UBool;
    pub fn uset_getSerializedRangeCount(set: *const USerializedSet)
     -> int32_t;
    pub fn uset_getSerializedRange(set: *const USerializedSet,
                                   rangeIndex: int32_t, pStart: *mut UChar32,
                                   pEnd: *mut UChar32) -> UBool;
}
