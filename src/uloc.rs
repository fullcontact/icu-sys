#![allow(unused_imports)]
/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
use libc;
use libc::*;
use utypes::*;
use ustring::*;
use utf8::*;
use utf16::*;
use uchar::*;
use uscript::*;
use uset::*;
use ucnv::*;
use ures::*;
use unorm2::*;
use ucal::*;
use udat::*;
use unum::*;
use utrans::*;
use ubidi::*;
use ushape::*;
use ucol::*;
use usearch::*;
use ubrk::*;
use uregex::*;
use usprep::*;
use uidna::*;
use uspoof::*;
use utmscale::*;
use umachine::*;
use parseerr::*;
use utext::*;
use uversion::*;
use uiter::*;
use uenum::*;
use urep::*;
use udisplaycontext::*;
use uformattable::*;
use umisc::*;
use ufieldpositer::*;
use ucnv_err::*;
use ucasemap::*;
use udata::*;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
#[derive(PartialEq,Eq,PartialOrd,Ord,Hash)]
pub enum ULocDataLocaleType {
    ULOC_ACTUAL_LOCALE = 0,
    ULOC_VALID_LOCALE = 1,
    ULOC_REQUESTED_LOCALE = 2,
    ULOC_DATA_LOCALE_TYPE_LIMIT = 3,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
#[derive(PartialEq,Eq,PartialOrd,Ord,Hash)]
pub enum ULayoutType {
    ULOC_LAYOUT_LTR = 0,
    ULOC_LAYOUT_RTL = 1,
    ULOC_LAYOUT_TTB = 2,
    ULOC_LAYOUT_BTT = 3,
    ULOC_LAYOUT_UNKNOWN = 4,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
#[derive(PartialEq,Eq,PartialOrd,Ord,Hash)]
pub enum UAcceptResult {
    ULOC_ACCEPT_FAILED = 0,
    ULOC_ACCEPT_VALID = 1,
    ULOC_ACCEPT_FALLBACK = 2,
}
#[link(name = "icuuc", kind = "static")]
#[link(name = "icudata", kind = "static")] 
#[link(name = "icui18n", kind = "static")] 
#[link(name = "stdc++", kind = "dylib")]
extern "C" {
    pub fn uloc_getDefault() -> *const ::libc::c_char;
    pub fn uloc_setDefault(localeID: *const ::libc::c_char,
                           status: *mut UErrorCode);
    pub fn uloc_getLanguage(localeID: *const ::libc::c_char,
                            language: *mut ::libc::c_char,
                            languageCapacity: int32_t, err: *mut UErrorCode)
     -> int32_t;
    pub fn uloc_getScript(localeID: *const ::libc::c_char,
                          script: *mut ::libc::c_char,
                          scriptCapacity: int32_t, err: *mut UErrorCode)
     -> int32_t;
    pub fn uloc_getCountry(localeID: *const ::libc::c_char,
                           country: *mut ::libc::c_char,
                           countryCapacity: int32_t, err: *mut UErrorCode)
     -> int32_t;
    pub fn uloc_getVariant(localeID: *const ::libc::c_char,
                           variant: *mut ::libc::c_char,
                           variantCapacity: int32_t, err: *mut UErrorCode)
     -> int32_t;
    pub fn uloc_getName(localeID: *const ::libc::c_char,
                        name: *mut ::libc::c_char, nameCapacity: int32_t,
                        err: *mut UErrorCode) -> int32_t;
    pub fn uloc_canonicalize(localeID: *const ::libc::c_char,
                             name: *mut ::libc::c_char, nameCapacity: int32_t,
                             err: *mut UErrorCode) -> int32_t;
    pub fn uloc_getISO3Language(localeID: *const ::libc::c_char)
     -> *const ::libc::c_char;
    pub fn uloc_getISO3Country(localeID: *const ::libc::c_char)
     -> *const ::libc::c_char;
    pub fn uloc_getLCID(localeID: *const ::libc::c_char) -> uint32_t;
    pub fn uloc_getDisplayLanguage(locale: *const ::libc::c_char,
                                   displayLocale: *const ::libc::c_char,
                                   language: *mut UChar,
                                   languageCapacity: int32_t,
                                   status: *mut UErrorCode) -> int32_t;
    pub fn uloc_getDisplayScript(locale: *const ::libc::c_char,
                                 displayLocale: *const ::libc::c_char,
                                 script: *mut UChar, scriptCapacity: int32_t,
                                 status: *mut UErrorCode) -> int32_t;
    pub fn uloc_getDisplayCountry(locale: *const ::libc::c_char,
                                  displayLocale: *const ::libc::c_char,
                                  country: *mut UChar,
                                  countryCapacity: int32_t,
                                  status: *mut UErrorCode) -> int32_t;
    pub fn uloc_getDisplayVariant(locale: *const ::libc::c_char,
                                  displayLocale: *const ::libc::c_char,
                                  variant: *mut UChar,
                                  variantCapacity: int32_t,
                                  status: *mut UErrorCode) -> int32_t;
    pub fn uloc_getDisplayKeyword(keyword: *const ::libc::c_char,
                                  displayLocale: *const ::libc::c_char,
                                  dest: *mut UChar, destCapacity: int32_t,
                                  status: *mut UErrorCode) -> int32_t;
    pub fn uloc_getDisplayKeywordValue(locale: *const ::libc::c_char,
                                       keyword: *const ::libc::c_char,
                                       displayLocale: *const ::libc::c_char,
                                       dest: *mut UChar,
                                       destCapacity: int32_t,
                                       status: *mut UErrorCode) -> int32_t;
    pub fn uloc_getDisplayName(localeID: *const ::libc::c_char,
                               inLocaleID: *const ::libc::c_char,
                               result: *mut UChar, maxResultSize: int32_t,
                               err: *mut UErrorCode) -> int32_t;
    pub fn uloc_getAvailable(n: int32_t) -> *const ::libc::c_char;
    pub fn uloc_countAvailable() -> int32_t;
    pub fn uloc_getISOLanguages() -> *const *const ::libc::c_char;
    pub fn uloc_getISOCountries() -> *const *const ::libc::c_char;
    pub fn uloc_getParent(localeID: *const ::libc::c_char,
                          parent: *mut ::libc::c_char,
                          parentCapacity: int32_t, err: *mut UErrorCode)
     -> int32_t;
    pub fn uloc_getBaseName(localeID: *const ::libc::c_char,
                            name: *mut ::libc::c_char, nameCapacity: int32_t,
                            err: *mut UErrorCode) -> int32_t;
    pub fn uloc_openKeywords(localeID: *const ::libc::c_char,
                             status: *mut UErrorCode) -> *mut UEnumeration;
    pub fn uloc_getKeywordValue(localeID: *const ::libc::c_char,
                                keywordName: *const ::libc::c_char,
                                buffer: *mut ::libc::c_char,
                                bufferCapacity: int32_t,
                                status: *mut UErrorCode) -> int32_t;
    pub fn uloc_setKeywordValue(keywordName: *const ::libc::c_char,
                                keywordValue: *const ::libc::c_char,
                                buffer: *mut ::libc::c_char,
                                bufferCapacity: int32_t,
                                status: *mut UErrorCode) -> int32_t;
    pub fn uloc_isRightToLeft(locale: *const ::libc::c_char) -> UBool;
    pub fn uloc_getCharacterOrientation(localeId: *const ::libc::c_char,
                                        status: *mut UErrorCode)
     -> ULayoutType;
    pub fn uloc_getLineOrientation(localeId: *const ::libc::c_char,
                                   status: *mut UErrorCode) -> ULayoutType;
    pub fn uloc_acceptLanguageFromHTTP(result: *mut ::libc::c_char,
                                       resultAvailable: int32_t,
                                       outResult: *mut UAcceptResult,
                                       httpAcceptLanguage:
                                           *const ::libc::c_char,
                                       availableLocales: *mut UEnumeration,
                                       status: *mut UErrorCode) -> int32_t;
    pub fn uloc_acceptLanguage(result: *mut ::libc::c_char,
                               resultAvailable: int32_t,
                               outResult: *mut UAcceptResult,
                               acceptList: *mut *const ::libc::c_char,
                               acceptListCount: int32_t,
                               availableLocales: *mut UEnumeration,
                               status: *mut UErrorCode) -> int32_t;
    pub fn uloc_getLocaleForLCID(hostID: uint32_t,
                                 locale: *mut ::libc::c_char,
                                 localeCapacity: int32_t,
                                 status: *mut UErrorCode) -> int32_t;
    pub fn uloc_addLikelySubtags(localeID: *const ::libc::c_char,
                                 maximizedLocaleID: *mut ::libc::c_char,
                                 maximizedLocaleIDCapacity: int32_t,
                                 err: *mut UErrorCode) -> int32_t;
    pub fn uloc_minimizeSubtags(localeID: *const ::libc::c_char,
                                minimizedLocaleID: *mut ::libc::c_char,
                                minimizedLocaleIDCapacity: int32_t,
                                err: *mut UErrorCode) -> int32_t;
    pub fn uloc_forLanguageTag(langtag: *const ::libc::c_char,
                               localeID: *mut ::libc::c_char,
                               localeIDCapacity: int32_t,
                               parsedLength: *mut int32_t,
                               err: *mut UErrorCode) -> int32_t;
    pub fn uloc_toLanguageTag(localeID: *const ::libc::c_char,
                              langtag: *mut ::libc::c_char,
                              langtagCapacity: int32_t, strict: UBool,
                              err: *mut UErrorCode) -> int32_t;
    pub fn uloc_toUnicodeLocaleKey(keyword: *const ::libc::c_char)
     -> *const ::libc::c_char;
    pub fn uloc_toUnicodeLocaleType(keyword: *const ::libc::c_char,
                                    value: *const ::libc::c_char)
     -> *const ::libc::c_char;
    pub fn uloc_toLegacyKey(keyword: *const ::libc::c_char)
     -> *const ::libc::c_char;
    pub fn uloc_toLegacyType(keyword: *const ::libc::c_char,
                             value: *const ::libc::c_char)
     -> *const ::libc::c_char;
}
